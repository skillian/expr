package expr

import "context"

type Func interface {
	Call(context.Context, []any) ([]any, error)
}

type FuncFunc func(context.Context, []any) ([]any, error)

func (f FuncFunc) Call(ctx context.Context, args []any) ([]any, error) {
	return f(ctx, args)
}

func func2x1[A0, A1 any, R0 any](f func(A0, A1) R0) Func {
	return FuncFunc(func(ctx context.Context, args []any) ([]any, error) {
		a0, err := typeAssertOrError[A0](args[0])
		if err != nil {
			return nil, err
		}
		a1, err := typeAssertOrError[A1](args[1])
		if err != nil {
			return nil, err
		}
		return []any{f(a0, a1)}, nil
	})
}

func func2x1err[A0, A1 any](f func(A0, A1) error) Func {
	ff := func2x1(f)
	return FuncFunc(func(ctx context.Context, args []any) ([]any, error) {
		res, err := ff.Call(ctx, args)
		if err != nil {
			return nil, err
		}
		if err, ok := res[0].(error); ok {
			return nil, err
		}
		return res, nil
	})
}

func typeAssert[T any](v any) T {
	x, err := typeAssertOrError[T](v)
	if err != nil {
		panic(err)
	}
	return x
}

func typeAssertOrError[T any](v any) (T, error) {
	x, ok := v.(T)
	if !ok {
		return x, makeInvalidType(x, v)
	}
	return x, nil
}
